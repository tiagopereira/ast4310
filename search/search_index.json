{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>These pages contain a description of AST4310 and additional resources. The pages at the University web site will still be updated (in particular the messages), but the bulk of the materials will be linked here.</p>"},{"location":"#practicalities","title":"Practicalities","text":"<ul> <li>Four hours of lectures and two hours of exercise classes per week (see calendar)</li> <li>Classes will be held in person unless otherwise directed</li> <li>See separate page for syllabus and literature</li> <li>The course's github repository contains all project notebooks, and will be populated with additional resources as the semester progresses</li> </ul>"},{"location":"#communication","title":"Communication","text":"<ul> <li>If you want to place questions about any aspect of AST4310, you can ask questions in our Discourse forum.</li> </ul>"},{"location":"#assessment","title":"Assessment","text":"<p>The final grade is determined by an assessment of three projects (50% of grade), and an oral exam (50% of grade). The following table lists deadlines for handing in each project, how much each project weighs in the final grade, and the topic of each project. More details can be found under projects. </p> Deadline Weight Project 1 19 Sep 15% Project 2 24 Oct 15% Project 3 28 Nov 20%"},{"location":"#required-software-and-tools","title":"Required software and tools","text":"<p>This course will have a strong computational component. Computations are not the end goal, but they will be an important tool to understand the topics we will cover. Research in astrophysics is becoming more and more computational; the course will equip students with the strategies and skills to deal with modern astrophysical problems. </p> <p>Students are expected to have their own laptops, and bring them to classes (including lectures!).</p> <p>The projects are in the Julia programming language in Jupyter notebook format. More details about the software and computing environment can be found in software and tools.</p>"},{"location":"julia/","title":"Quick guide to Julia from Python","text":"<p>Julia is a programming language designed for speed and ease of use. It aims to be as fast as C and as easy to code as Python. In fact, writing Julia code can be remarkably similar to Python, but there are a few important differences to be aware. </p> <p>Here, we highlight how to perform some basic tasks with Julia, and how they compare with their Python equivalent. But first, a quick primer on what Julia is.</p>"},{"location":"julia/#julia-in-nutshell","title":"Julia in nutshell","text":"<p>Julia is a dynamically-typed language that feels more like a scripting language (e.g. Python) than a compiled language (e.g. C, Fortran). However, code in Julia is indeed compiled, but this step is hidden from the user by using just-in-time compilation. It works similar to Numba in Python. A difference is that Numba can be used with a very limited set of libraries/functions, while Julia is much more general. </p> <p>Julia can be run interactively from a terminal or a Jupyter notebook. The Julia terminal programme is referred to as REPL. A julia programme can also be run as a script, or placed in a package. Julia has its own package manager that is very easy to use.</p> <p>A key feature of Julia is called multiple dispatch. With multiple dispatch, Julia can split a function in several versions that are optimised for different inputs. For example, a multiplication function can have a version optimised for integers and another version optimised for floating point numbers. When a user calls that function, Julia automatically dispatches the call to the optimal function. In Julia, unlike Python, you can define the same function name multiple times and this will not cause problems, as long as each version has an input with a different data type.</p>"},{"location":"julia/#julia-for-python-programmers","title":"Julia for Python programmers","text":"<p>Read the manual on important differences from Python. Most importantly, Julia blocks are terminated by <code>end</code> keywords and indentation is not significant, and indexing starts at 1 instead of 0, and is column major (Fortran order) instead of row major (C/C++ order). </p> <p>All the array functionality and many mathematical functions are built-in into Julia, instead of being in separate packages like in Python (e.g. <code>math</code>, <code>numpy</code>, <code>scipy</code>).  </p> <p>There are no classes in Julia. The closest thing are structures, which can be used to store data (similar to class attributes in Python), but have no methods. </p> <p>Here are a few translations of common operations:</p> Python Julia <code>numpy.shape()</code> <code>size()</code> <code>len()</code> <code>length()</code> <code>type()</code> <code>typeof()</code> <code>range(1,5)</code> <code>1:4</code> <code>numpy.linspace(0, 2, 10)</code> <code>range(0, 2, 10)</code> <code>numpy.squeeze()</code> <code>dropdims</code> <code>import</code> <code>using</code> <code>my_array[-1]</code> <code>my_array[end]</code> <code>5 // 2</code> <code>5 \u00f7 2</code> <code>2**3</code> <code>2^3</code> <code>1 + 5j</code> <code>1 + 5im</code>"},{"location":"julia/#basic-operations-in-julia","title":"Basic operations in Julia","text":""},{"location":"julia/#functions","title":"Functions","text":"Julia Python <pre><code>function my_sum(x, y)\n    return x + y\nend\n</code></pre> <pre><code>def my_sum(x, y):\n    return x + y\n</code></pre> <p>or in one line:</p>  Julia Python <pre><code>my_sum(x, y) = x + y\n</code></pre> <pre><code>my_sum = lambda x, y: x + y\n</code></pre>"},{"location":"julia/#control-flow","title":"Control flow","text":"<p>Loops:</p>  Julia Python <pre><code>for i in 1:5\n    println(i)\nend\n</code></pre> <pre><code>for i in range(1,6):\n    print(i)\n</code></pre> <p><code>if</code>, <code>then</code>, <code>else</code></p>  Julia Python <pre><code>if x &lt; y\n    println(\"x is less than y\")\nelseif x &gt; y\n    println(\"x is greater than y\")\nelse\n    println(\"x is equal to y\")\nend\n</code></pre> <pre><code>if x &lt; y:\n    print('x is less than y')\nelif x &gt; y:\n    print('x is greater than y')\nelse:\n    print('x is equal to y')\n</code></pre>"},{"location":"julia/#arrays","title":"Arrays","text":"<p>Creating arrays. For Python, assume we <code>import numpy as np</code>.</p>  Julia Python <pre><code>a = [1., 5, 6, 10]\n</code></pre> <pre><code>a = np.array([1., 5, 6, 10])\n</code></pre> <p>Uninitiated arrays:</p>  Julia Python <pre><code>a = Array{Float32}(undef, 100, 100)\n</code></pre> <pre><code>a = np.empty((100, 100), np.float32)\n</code></pre> <p>Slicing and indexing</p>  Julia Python <pre><code>a[1]\na[end]\na[end-1]\n# If a is a 2D array:\na[5:9, 10:15]\n</code></pre> <pre><code>a[0]\na[-1]\na[-2]\n# If a is a 2D array:\na[4:9, 9:15]\n</code></pre> <p>Element-wise multiplication of arrays:</p>  Julia Python <pre><code>a .* b\n</code></pre> <pre><code>a * b\n</code></pre> <p>Matrix multiplication:</p>  Julia Python <pre><code>a * b\n</code></pre> <pre><code>a @ b\n</code></pre>"},{"location":"julia/#interpolation","title":"Interpolation","text":"<p>Linear interpolation:</p>  Julia Python <pre><code>using Interpolations\n\nx = range(0, 4\u03c0, 50)\ny = cos.(x)\ninterp_linear = linear_interpolation(x, y)\n\nnew_x = [2, 4, 6, 8, 10, 12]\nnew_y = interp_linear.(new_x)\n</code></pre> <pre><code>import numpy as np\n\nx = np.linspace(0, 4*np.pi, 50)\ny = np.cos(x)\n\nnew_x = [2, 4, 6, 8, 10, 12]\nnew_y = np.interp(new_x, x, y)\n</code></pre>"},{"location":"julia/#plots","title":"Plots","text":"<p>For Julia, using Makie. For Python, using Matplotlib.</p> <p>Simple plots:</p>  Julia Python <p>In the REPL, use <code>GLMakie</code> for interactive plots. In the notebook, <code>CairoMakie</code> for static plots or <code>WGLMakie</code> for interactive plots (may not work in Jupyter). <pre><code>using CairoMakie\n\nx = range(0, 4\u03c0, 100)\ny = cos.(x)\n\nfig = Figure(size=(500,300))\nax = Axis(fig[1,1], xlabel=\"Time (s)\", ylabel=\"Signal (mV)\", title=\"Some data\")\nlines!(ax, x, y, color=:red)\nscatter!(ax, x[1:10:end], y[1:10:end], color=:blue)\nfig\n</code></pre></p> <pre><code>%matplotlib inline\n\nimport matplotlib.pylab as plt\nimport numpy as np\n\nx = np.linspace(0, 4*np.pi, 100)\ny = np.cos(x)\n\nfig, ax = plt.subplots(figsize=(5, 3), dpi=100)\n\nax.plot(x, y, 'r-')\nax.plot(x[::10], y[::10], 'bo')\nax.set_xlabel('Time (s)')\nax.set_ylabel('Signal (mV)')\nax.set_title('Some data')\n</code></pre> <p>Plotting images:</p>  Julia Python <pre><code>xs = range(0, 2\u03c0, length=100)\nzs = [sin(x * y) for x in xs, y in xs]\n\nfig, ax, hm = heatmap(xs, ys, zs; colormap=:inferno)\nColorbar(fig[:, end+1], hm)\nfig\n</code></pre> <pre><code>tmp = np.linspace(0, 2*np.pi, 100)\nxs, ys = np.meshgrid(tmp, tmp)\nzs = np.sin(xs * ys)\n\nc = plt.imshow(zs, cmap='inferno', \n               extent=(0, 2*np.pi, 0, 2*np.pi))\nplt.colorbar(c)\n</code></pre>"},{"location":"literature/","title":"Syllabus and literature","text":""},{"location":"literature/#syllabus","title":"Syllabus","text":"<p>The syllabus follows closely chapters of the lecture notes, except the last point:</p> <ol> <li>Radiation quantities</li> <li>Radiation and matter in equilibrium</li> <li>The radiative transfer equation</li> <li>Discrete processes</li> <li>Continuous processes</li> <li>Radiative transfer</li> <li>Zeeman effect and polarised radiative transfer</li> </ol>"},{"location":"literature/#literature","title":"Literature","text":"<p>You can also view the literature list in Leganto.</p> <ul> <li>Lecture notes: Introduction to Astrophysical Radiative Transfer by Rob Rutten</li> <li>Radiative processes in astrophysics by George Rybicki and Alan Lightman</li> <li>The observation and analysis of stellar photospheres by David Gray</li> <li>Introduction to stellar astrophysics, vol.2 : Stellar atmospheres by Erika B\u00f6hm-Vitense</li> <li>Radiative Processes in High Energy Astrophysics by Gabriele Ghiselline</li> <li>Astrophysics of the Diffuse Universe by Mike Dopita and Ralph Sutherland</li> <li>Radiative Transfer in Stellar Atmospheres by Rob Rutten (more advanced version of the lecture notes with focus on stellar atmospheres)</li> </ul>"},{"location":"literature/#additional-resources-for-zeeman-effect-and-polarised-radiative-transfer","title":"Additional resources for Zeeman effect and polarised radiative transfer","text":"<ul> <li>Polarization in Spectral Lines by Egidio Landi Degl'Innoccenti &amp; Marco Landolfi. Advanced level, but THE reference text for all things related to Zeeman effect and polarisation. Chapter 3 (Zeeman effect) and Chapter 9 (Line Formation in a Magnetic Field) are the most relevant.</li> <li>Modern Physics by Paul Tipler and Ralph Llewellyn. A more introductory-level text on Quantum Physics &amp; Relativity, with most relevant chapter 7 on Atomic Physics. Some additional sections are available online for free and are highly recommended:<ul> <li>Modern Physics, Multielectron Atoms</li> <li>Modern Physics, The Zeeman Effect</li> </ul> </li> <li>Radiative Diagnostics in the Solar Photosphere and Chromosphere by Jaime de la Cruz Rodr\u00edguez and Michiel van Noort. Freely available online, only sections 2.1 and 2.2 are relevant.</li> </ul>"},{"location":"projects/","title":"Projects","text":""},{"location":"projects/#overview","title":"Overview","text":"<p>There are a total of three projects, to be handed in at different times and with a different weight on the final grade, as listed below.</p> Deadline Weight Project 1 19 Sep 15% Project 2 24 Oct 15% Project 3 28 Nov 20%"},{"location":"projects/#repository","title":"Repository","text":"<p>The project descriptions and questions are given in Jupyter notebook format, and can be found at the course's github repository. </p> <p>Most of the time you should be using Jupyter lab or VSCode/VSCodium. In some cases the LaTeX parts in Markdown may render poorly, especially in VSCode. For Jupyter lab you can try waiting a bit, or re-running (Ctrl+Enter) the problematic markdown cells. In some cases, making a small change (e.g. adding a space) and re-running the cell fixes the problem.</p>"},{"location":"projects/#format-and-delivery","title":"Format and delivery","text":"<p>The projects should be handed in as Jupyter notebooks (in Julia). The assignments will be handed using Devilry. The projects should be handed in groups of two. In exceptional cases, they can be handed individually or in groups of three.</p> <p>Info</p> <p>Groups are not enabled in Devilry. This means that students in a group will need to submit the same files on Devilry. This is because peer review is individual (see below), therefore group members will not necessarily have the same final grade for a project.</p> <p>In addition to the notebook file, you should upload also all necessary files to run a notebook, or additional files you created along your notebook (e.g. a data file with the results of a long calculation). You do not need to upload the additional files that were present in the repository (e.g. atom files, images, etc.). Loading data files or code from the internet is not allowed.</p>"},{"location":"projects/#grading","title":"Grading","text":""},{"location":"projects/#final-grade","title":"Final grade","text":"<p>The final grade is the 50/50 average of the final grade for all projects (numerical, from 0 to 100) and the grade from the oral exam (letter, from F to A). To convert project and oral exam grades to the final grade, we will use the following table, where the rows are different project grades and the columns different oral exam grades:</p> Project / Oral F E D C B A 0-39 F F F F F F 40-45 F E E D D C 46-51 F E D D C C 52-57 F D D C C C 58-67 F D D C C B 67-76 F D C C B B 77-84 F C C C B B 85-91 F C C B B A 92-96 F C C B B A 96-100 F C B B A A"},{"location":"projects/#project-grade","title":"Project grade","text":"<p>The project weights are specified in the table at the top of this page. Each project will have a numerical grade between 0 and 100, and the final project grade is the weighed sum of all project grades, rounded to the closest integer. </p> <p>For the 100 points assigned to each project, 95 points are for the report itself (Jupyter notebook), and 5 points are given for peer review. </p>"},{"location":"projects/#peer-review","title":"Peer review","text":"<p>To mimic the peer-review process in scientific publications, you will have the opportunity to review the work of your colleagues. The main goal of peer review is to give constructive feedback so that your colleagues can learn from their mistakes and improve the submission. Peer review is optional. It will give up to 5 points that will be added to your project grade. If you have a perfect score in the project but elect not to do peer review, you will get a grade of 95. </p> <p>Peer review will be double-blind and individual. Each element of a group will be given a different assignment to review. It is expected that the 5 points will be awarded for most peer reviews, although obviously low-quality peer reviews will receive zero points. Borderline cases may be given less than 5 points. Examples of a low-quality review are:</p> <ul> <li>Few comments on the work</li> <li>Mostly meaningless or off-the-mark comments, where it is obvious the reviewer did not properly read the work</li> <li>Contains offensive or inappropriate comments</li> </ul> <p>Examples of meaningless comments are: Nice work!, You did a good plot here!, Very good!. These may be encouraging, but they don't provide any feedback to your colleagues. It's fine to give positive feedback, but please be specific, e.g.: This part was easy to read, I enjoyed how you linked your findings to the lecture materials., This is a nice plot because the two cases are clearly distinguishable, and the lines/marking are easy to see.</p>"},{"location":"projects/#peer-review-for-the-reviewer","title":"Peer review for the reviewer","text":"<ul> <li> <p>After the projects are handed in in Devilry, we will work quickly to assign you a project to review. A Jupyter notebook will be sent to you on Devilry. The project deadlines are on Fridays; you should expect to receive your assignment on the following Monday.</p> </li> <li> <p>The deadline to submit peer review is one week after the original submission deadline (ie, Friday to Friday).</p> </li> <li> <p>Write your review in the notebook you receive, by adding additional markdown cells, enclosing your comments with an HTML box of the following kind (please do not change the colour of the <code>div</code> box):</p> </li> </ul> <pre><code>&lt;div style=\"background-color:#e6e6e6; padding:10px; border-style:\nsolid;; border-color:#0d0d0d; border-width:1px; color: black;\"&gt;\n\nYour markdown comments here.\n\n* Can also use\n* a bulleted list,\n\nOther markdown, LaTeX: $\\epsilon$, etc.\n\n&lt;/div&gt;\n</code></pre> <ul> <li>Your job as a reviewer is to find out if each question is adequately answered, for example by answering the following questions:<ul> <li>Are the assumptions correct, and well spelled out?</li> <li>Are the computations adequate to the job, and the code easy to read?</li> <li>Are there any major flaws in the answer(s)?</li> <li>Is the text well-written and concise?</li> <li>Are plots well laid out?</li> </ul> </li> <li>You don't need to answer all of the above, or go exhaustively through the calculations or the code. The point is more to look at the big picture.</li> <li>It is not the job of the reviewer to spell check or correct the language (in scientific publications, this is the job of the editor and/or language editor). If you find there are too many language errors, you can mention it as a general comment, e.g.: This work would benefit from some proofreading, there are several typos and grammatical errors.</li> <li>It is not the job of the reviewer to force her/his view into the writing of the answers, but provide a neutral viewpoint. </li> <li>Do not be afraid to point out mistakes if you find them, but always try to do so in a constructive manner and criticise the work, not the person. Write your feedback as you would like to receive it.</li> <li>Avoid discussing your peer review assignments with your colleagues. </li> </ul>"},{"location":"projects/#peer-review-for-the-authors","title":"Peer review for the authors","text":"<ul> <li>About one week after the original submission deadline, you will receive feedback from the teachers plus any feedback from peer review</li> <li>Comments you receive from peer review will not affect your grade, only the assessment by the teachers.</li> <li>Do not take the comments from peer review at face value. It is possible that the reviewer is wrong.</li> <li>Do not take any negative comments personally. The reviewer is commenting on the work that you submitted, not on you as a person.</li> <li>Avoid discussing the comments from peer review outside your group, and especially do not confront other students or suggest she/he was the referee.</li> </ul>"},{"location":"tools/","title":"Software and Tools","text":""},{"location":"tools/#widgets","title":"Widgets","text":"<p>Here is a list of interactive widgets that we'll go over during the lectures:</p> <ul> <li>Slab line formation</li> <li>Line formation in a 1D atmosphere</li> </ul>"},{"location":"tools/#programming-language","title":"Programming language","text":"<p>This course can be followed using the Julia programming language. Why Julia? Julia is a new language designed from scratch for fast scientific calculations, and has a large and growing ecosystem, especially for astronomy, visualisation, and data science. If you are familiar with Python, using Julia will be similar and in AST4310 we will use simple interfaces to the language. Read our guide to Julia when coming from Python.</p> <p>Besides the programming language used to run code, jupyter notebooks have a text component using the Markdown language. It will be used extensively in your project reports, and you are encouraged to get more familiar with it. The Markdown cheatsheet is a good reference. Familiarity with LaTeX is also important, but mostly to write equations, which can be included in Markdown using LaTeX syntax.</p>"},{"location":"tools/#jupyterhub","title":"JupyterHub","text":"<p>It may be possible to run Julia from JupyterHub at UiO. Check this page again later for updates.</p>"},{"location":"tools/#installing-julia-and-necessary-packages","title":"Installing Julia and necessary packages","text":"<p>Julia is open source and available for most operative systems. It is already installed in the linux machines at the Institute, and it is possible to connect to this system remotely with Jupyter in your browser (see below for details). We recommend you use Jupyter lab or VSCode/VSCodium for interacting with Julia notebooks.</p> <p>Start by installing Julia itself:</p> macOS or Linux laptopWindows laptopInstitute linux machines <p>Open a terminal and run: <pre><code>curl -fsSL https://install.julialang.org | sh\n</code></pre></p> <p>Install <code>juliaup</code> from the Microsoft Store. This can also be installed from the terminal: <pre><code>&gt; winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n</code></pre></p> <p>Julia is already installed in the Institute's linux machines, but its module needs to be loaded from the terminal: <pre><code>$ module load julia\n</code></pre></p> <p>Then start <code>julia</code> in the terminal:</p> <pre><code>$ julia\n</code></pre> <p>This should start the Julia REPL, and you'll see a prompt with <code>julia&gt;</code>. Press the <code>]</code> key to enter the Julia package manager, and the prompt should change to something like <code>(@v1.11) pkg&gt;</code>. Here, you will install several basic packages with the command:</p> <pre><code>(@v1.11) pkg&gt; add CairoMakie Colors HDF5 IJulia Interpolations NumericalIntegration PhysicalConstants  Unitful \n</code></pre> <p>One of the packages above is <code>IJulia</code>, which will install Julia kernels for Jupyter. These should show when you restart Jupyter lab or Jupyter notebook. For VSCode or VSCodium, it is recommended you install the extensions <code>Julia</code> and <code>Jupyter</code>.</p>"},{"location":"tools/#running-julia-remotely-from-the-institute","title":"Running Julia remotely from the Institute","text":"<p>If you are using Julia from the Institute's linux machines, it is possible to connect remotely via the browser in your laptop.</p> <p>Warning</p> <p>This procedure is technically more difficult and prone to failure, so it is recommended for advanced terminal users only.</p> <p>Setting up Julia at the Institute is very similar to the setup of Python. Start by setting up your Python environment following the documentation, and ensure that your <code>py313</code> environment is loaded. Follow section 2 to start jupyter lab remotely. When you start Jupyter, you should see a Julia kernel when you start a new notebook.</p> <p>To ssh to your machine of choice, it is recommended to configure your ssh keys and ssh agent to avoid having to enter your password several times. Adding a proxy to your <code>~/.ssh/config</code> makes connecting even easier:</p> <pre><code>Host my_machine\n    ForwardX11 yes\n    ProxyJump username@login.astro.uio.no\n</code></pre>"}]}